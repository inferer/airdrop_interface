{"ast":null,"code":"import { NETWORK_CHAIN_ID } from '../connectors';\nimport { ST_TOKEN_LIST, AIR_TOKEN_LIST, AIRLABEL_TOKEN_LIST } from '../constants/tokenList';\nimport { AIRLABEL_TOKEN_LIST_URL, AIR_TOKEN_LIST_URL } from '../constants/lists';\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */\n\nexport default async function getTokenList(listUrl, resolveENSContentHash) {\n  let response;\n\n  try {\n    response = await fetch('/tokens/tokenlist.json');\n\n    if (!response.ok) {}\n\n    const json = await response.json();\n    return json;\n  } catch (error) {\n    console.debug('Failed to fetch list', listUrl, error);\n  }\n}\nconst template = {\n  \"name\": \"\",\n  \"timestamp\": \"\",\n  \"version\": {\n    \"major\": 1\n  },\n  \"tags\": {},\n  \"logoURI\": \"\",\n  \"keywords\": [],\n  \"tokens\": []\n};\nexport function filterTokenByChainId(tokens) {\n  return tokens.filter(token => token.chainId === NETWORK_CHAIN_ID);\n}\nexport async function getTokenListLocal(listUrl) {\n  let tokens = {};\n\n  if (listUrl === AIR_TOKEN_LIST_URL) {\n    tokens = filterTokenByChainId(AIR_TOKEN_LIST);\n  } else if (listUrl === AIRLABEL_TOKEN_LIST_URL) {\n    tokens = filterTokenByChainId(AIRLABEL_TOKEN_LIST);\n  } else {\n    tokens = filterTokenByChainId(ST_TOKEN_LIST);\n  }\n\n  return { ...template,\n    name: listUrl,\n    timestamp: new Date().toLocaleString(),\n    tokens: tokens\n  };\n}","map":{"version":3,"sources":["/Users/xuyanjun/workspace/vision/airdrop_protocol/airdrop_interface/src/utils/getTokenList.ts"],"names":["NETWORK_CHAIN_ID","ST_TOKEN_LIST","AIR_TOKEN_LIST","AIRLABEL_TOKEN_LIST","AIRLABEL_TOKEN_LIST_URL","AIR_TOKEN_LIST_URL","getTokenList","listUrl","resolveENSContentHash","response","fetch","ok","json","error","console","debug","template","filterTokenByChainId","tokens","filter","token","chainId","getTokenListLocal","name","timestamp","Date","toLocaleString"],"mappings":"AAEA,SAASA,gBAAT,QAAiC,eAAjC;AACA,SAASC,aAAT,EAAwBC,cAAxB,EAAwCC,mBAAxC,QAAmE,wBAAnE;AACA,SAASC,uBAAT,EAAkCC,kBAAlC,QAA4D,oBAA5D;AAEA;;;;;;AAKA,eAAe,eAAeC,YAAf,CACbC,OADa,EAEbC,qBAFa,EAGC;AACd,MAAIC,QAAJ;;AACE,MAAI;AACFA,IAAAA,QAAQ,GAAG,MAAMC,KAAK,CAAC,wBAAD,CAAtB;;AACA,QAAI,CAACD,QAAQ,CAACE,EAAd,EAAkB,CAEjB;;AACD,UAAMC,IAAI,GAAG,MAAMH,QAAQ,CAACG,IAAT,EAAnB;AACA,WAAOA,IAAP;AACD,GAPD,CAOE,OAAOC,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACC,KAAR,CAAc,sBAAd,EAAsCR,OAAtC,EAA+CM,KAA/C;AAED;AACJ;AAED,MAAMG,QAAQ,GAAG;AACf,UAAQ,EADO;AAEf,eAAa,EAFE;AAGf,aAAW;AACT,aAAS;AADA,GAHI;AAMf,UAAQ,EANO;AAOf,aAAW,EAPI;AAQf,cAAY,EARG;AAUf,YAAU;AAVK,CAAjB;AAaA,OAAO,SAASC,oBAAT,CAA8BC,MAA9B,EAAmD;AACxD,SAAOA,MAAM,CAACC,MAAP,CAAcC,KAAK,IAAIA,KAAK,CAACC,OAAN,KAAkBrB,gBAAzC,CAAP;AACD;AAED,OAAO,eAAesB,iBAAf,CACLf,OADK,EAES;AACd,MAAIW,MAAM,GAAG,EAAb;;AACA,MAAIX,OAAO,KAAKF,kBAAhB,EAAoC;AAClCa,IAAAA,MAAM,GAAGD,oBAAoB,CAACf,cAAD,CAA7B;AACD,GAFD,MAEO,IAAIK,OAAO,KAAKH,uBAAhB,EAAyC;AAC9Cc,IAAAA,MAAM,GAAGD,oBAAoB,CAACd,mBAAD,CAA7B;AACD,GAFM,MAEA;AACLe,IAAAA,MAAM,GAAGD,oBAAoB,CAAChB,aAAD,CAA7B;AACD;;AAED,SAAO,EACL,GAAGe,QADE;AAELO,IAAAA,IAAI,EAAEhB,OAFD;AAGLiB,IAAAA,SAAS,EAAE,IAAIC,IAAJ,GAAWC,cAAX,EAHN;AAILR,IAAAA,MAAM,EAAEA;AAJH,GAAP;AAOD","sourcesContent":["import { TokenList, TokenInfo } from '@uniswap/token-lists'\n\nimport { NETWORK_CHAIN_ID } from '../connectors'\nimport { ST_TOKEN_LIST, AIR_TOKEN_LIST, AIRLABEL_TOKEN_LIST } from '../constants/tokenList'\nimport { AIRLABEL_TOKEN_LIST_URL, AIR_TOKEN_LIST_URL } from '../constants/lists'\n\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */\nexport default async function getTokenList(\n  listUrl: string,\n  resolveENSContentHash?: (ensName: string) => Promise<string>\n): Promise<any> {\n  let response\n    try {\n      response = await fetch('/tokens/tokenlist.json')\n      if (!response.ok) {\n      \n      }\n      const json = await response.json()\n      return json as TokenList\n    } catch (error) {\n      console.debug('Failed to fetch list', listUrl, error)\n      \n    }\n}\n\nconst template = {\n  \"name\": \"\",\n  \"timestamp\": \"\",\n  \"version\": {\n    \"major\": 1\n  },\n  \"tags\": {},\n  \"logoURI\": \"\",\n  \"keywords\": [\n  ],\n  \"tokens\": [ ]\n}\n\nexport function filterTokenByChainId(tokens: TokenInfo[]) {\n  return tokens.filter(token => token.chainId === NETWORK_CHAIN_ID)\n}\n\nexport async function getTokenListLocal(\n  listUrl: string,\n): Promise<any> {\n  let tokens = {}\n  if (listUrl === AIR_TOKEN_LIST_URL) {\n    tokens = filterTokenByChainId(AIR_TOKEN_LIST)\n  } else if (listUrl === AIRLABEL_TOKEN_LIST_URL) {\n    tokens = filterTokenByChainId(AIRLABEL_TOKEN_LIST)\n  } else {\n    tokens = filterTokenByChainId(ST_TOKEN_LIST)\n  }\n\n  return {\n    ...template,\n    name: listUrl,\n    timestamp: new Date().toLocaleString(),\n    tokens: tokens\n  }\n  \n}\n"]},"metadata":{},"sourceType":"module"}