{"ast":null,"code":"import { parseBytes32String } from '@ethersproject/strings';\nimport { Token, currencyEquals } from '@uniswap/sdk';\nimport { useMemo } from 'react';\nimport { useAirLabelTokenList, useAirTokenList, useSelectedTokenList } from '../state/lists/hooks';\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks';\nimport { useUserAddedTokens } from '../state/user/hooks';\nimport { isAddress } from '../utils';\nimport { useActiveWeb3React } from './index';\nimport { useBytes32TokenContract, useTokenContract } from './useContract';\nexport function useAllTokens() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  const allTokens = useSelectedTokenList();\n  return useMemo(() => {\n    if (!chainId) return {};\n    return allTokens[chainId]; // const currentTokens = Object.values(allTokens[chainId])\n    // console.log(currentTokens)\n    // return (\n    //   userAddedTokens\n    //     // reduce into all ALL_TOKENS filtered by the current chain\n    //     .reduce<{ [address: string]: Token }>(\n    //       (tokenMap, token) => {\n    //         // console.log(tokenMap, token)\n    //         tokenMap[token.address] = token\n    //         return tokenMap\n    //       },\n    //       // must make a copy because reduce modifies the map, and we do not\n    //       // want to make a copy in every iteration\n    //       { ...allTokens[chainId] }\n    //     )\n    // )\n  }, [chainId, userAddedTokens, allTokens]);\n}\nexport function useAirAllTokens() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  const allTokens = useAirTokenList();\n  return useMemo(() => {\n    if (!chainId) return {};\n    return userAddedTokens // reduce into all ALL_TOKENS filtered by the current chain\n    .reduce((tokenMap, token) => {\n      tokenMap[token.address] = token;\n      return tokenMap;\n    }, // must make a copy because reduce modifies the map, and we do not\n    // want to make a copy in every iteration\n    { ...allTokens[chainId]\n    });\n  }, [chainId, userAddedTokens, allTokens]);\n}\nexport function useAirLabelAllTokens() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const userAddedTokens = useUserAddedTokens();\n  const allTokens = useAirLabelTokenList();\n  return useMemo(() => {\n    if (!chainId) return {};\n    return userAddedTokens // reduce into all ALL_TOKENS filtered by the current chain\n    .reduce((tokenMap, token) => {\n      tokenMap[token.address] = token;\n      return tokenMap;\n    }, // must make a copy because reduce modifies the map, and we do not\n    // want to make a copy in every iteration\n    { ...allTokens[chainId]\n    });\n  }, [chainId, userAddedTokens, allTokens]);\n} // Check if currency is included in custom list from user storage\n\nexport function useIsUserAddedToken(currency) {\n  const userAddedTokens = useUserAddedTokens();\n  return !!userAddedTokens.find(token => currencyEquals(currency, token));\n} // parse a name or symbol from a token response\n\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/;\n\nfunction parseStringOrBytes32(str, bytes32, defaultValue) {\n  return str && str.length > 0 ? str : bytes32 && BYTES32_REGEX.test(bytes32) ? parseBytes32String(bytes32) : defaultValue;\n} // undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\n\n\nexport function useToken(tokenAddress) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const allTokens = useAllTokens();\n  const airLabelTokens = useAirLabelAllTokens();\n  const tokens = useMemo(() => ({ ...allTokens,\n    ...airLabelTokens\n  }), [allTokens, airLabelTokens]);\n  const address = isAddress(tokenAddress);\n  const tokenContract = useTokenContract(address ? address : undefined, false);\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false);\n  const token = address ? tokens[address] : undefined;\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD);\n  const tokenNameBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'name', undefined, NEVER_RELOAD);\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD);\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD);\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD);\n  return useMemo(() => {\n    if (token) return token;\n    if (!chainId || !address) return undefined;\n    if (decimals.loading || symbol.loading || tokenName.loading) return null;\n\n    if (decimals.result) {\n      var _symbol$result, _symbolBytes32$result, _tokenName$result, _tokenNameBytes32$res;\n\n      return new Token(chainId, address, decimals.result[0], parseStringOrBytes32((_symbol$result = symbol.result) === null || _symbol$result === void 0 ? void 0 : _symbol$result[0], (_symbolBytes32$result = symbolBytes32.result) === null || _symbolBytes32$result === void 0 ? void 0 : _symbolBytes32$result[0], 'UNKNOWN'), parseStringOrBytes32((_tokenName$result = tokenName.result) === null || _tokenName$result === void 0 ? void 0 : _tokenName$result[0], (_tokenNameBytes32$res = tokenNameBytes32.result) === null || _tokenNameBytes32$res === void 0 ? void 0 : _tokenNameBytes32$res[0], 'Unknown Token'));\n    }\n\n    return undefined;\n  }, [address, chainId, decimals.loading, decimals.result, symbol.loading, symbol.result, symbolBytes32.result, token, tokenName.loading, tokenName.result, tokenNameBytes32.result]);\n}\nexport function useCurrency(currencyId) {\n  // const isETH = currencyId?.toUpperCase() === 'ETH'\n  // const token = useToken(isETH ? undefined : currencyId)\n  // return isETH ? ETHER : token\n  return useToken(currencyId);\n}","map":{"version":3,"sources":["/Users/xuyanjun/workspace/vision/airdrop_protocol/airdrop_interface/src/hooks/Tokens.ts"],"names":["parseBytes32String","Token","currencyEquals","useMemo","useAirLabelTokenList","useAirTokenList","useSelectedTokenList","NEVER_RELOAD","useSingleCallResult","useUserAddedTokens","isAddress","useActiveWeb3React","useBytes32TokenContract","useTokenContract","useAllTokens","chainId","userAddedTokens","allTokens","useAirAllTokens","reduce","tokenMap","token","address","useAirLabelAllTokens","useIsUserAddedToken","currency","find","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","airLabelTokens","tokens","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","useCurrency","currencyId"],"mappings":"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","sourcesContent":["import { parseBytes32String } from '@ethersproject/strings'\nimport { Currency, ETHER, Token, currencyEquals } from '@uniswap/sdk'\nimport { useMemo } from 'react'\nimport { useAirLabelTokenList, useAirTokenList, useSelectedTokenList } from '../state/lists/hooks'\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks'\nimport { useAddUserToken, useUserAddedTokens } from '../state/user/hooks'\nimport { isAddress } from '../utils'\n\nimport { useActiveWeb3React } from './index'\nimport { useBytes32TokenContract, useTokenContract } from './useContract'\n\nexport function useAllTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const userAddedTokens = useUserAddedTokens()\n  const allTokens = useSelectedTokenList()\n  return useMemo(() => {\n    if (!chainId) return {}\n    return allTokens[chainId]\n    // const currentTokens = Object.values(allTokens[chainId])\n    // console.log(currentTokens)\n    // return (\n    //   userAddedTokens\n    //     // reduce into all ALL_TOKENS filtered by the current chain\n    //     .reduce<{ [address: string]: Token }>(\n    //       (tokenMap, token) => {\n    //         // console.log(tokenMap, token)\n    //         tokenMap[token.address] = token\n    //         return tokenMap\n    //       },\n    //       // must make a copy because reduce modifies the map, and we do not\n    //       // want to make a copy in every iteration\n    //       { ...allTokens[chainId] }\n    //     )\n    // )\n  }, [chainId, userAddedTokens, allTokens])\n}\n\n\nexport function useAirAllTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const userAddedTokens = useUserAddedTokens()\n  const allTokens = useAirTokenList()\n\n  return useMemo(() => {\n    if (!chainId) return {}\n    return (\n      userAddedTokens\n        // reduce into all ALL_TOKENS filtered by the current chain\n        .reduce<{ [address: string]: Token }>(\n          (tokenMap, token) => {\n            tokenMap[token.address] = token\n            return tokenMap\n          },\n          // must make a copy because reduce modifies the map, and we do not\n          // want to make a copy in every iteration\n          { ...allTokens[chainId] }\n        )\n    )\n  }, [chainId, userAddedTokens, allTokens])\n}\n\nexport function useAirLabelAllTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const userAddedTokens = useUserAddedTokens()\n  const allTokens = useAirLabelTokenList()\n\n  return useMemo(() => {\n    if (!chainId) return {}\n    return (\n      userAddedTokens\n        // reduce into all ALL_TOKENS filtered by the current chain\n        .reduce<{ [address: string]: Token }>(\n          (tokenMap, token) => {\n            tokenMap[token.address] = token\n            return tokenMap\n          },\n          // must make a copy because reduce modifies the map, and we do not\n          // want to make a copy in every iteration\n          { ...allTokens[chainId] }\n        )\n    )\n  }, [chainId, userAddedTokens, allTokens])\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency: Currency): boolean {\n  const userAddedTokens = useUserAddedTokens()\n  return !!userAddedTokens.find(token => currencyEquals(currency, token))\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\n  return str && str.length > 0\n    ? str\n    : bytes32 && BYTES32_REGEX.test(bytes32)\n    ? parseBytes32String(bytes32)\n    : defaultValue\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress?: string): Token | undefined | null {\n  const { chainId } = useActiveWeb3React()\n  const allTokens = useAllTokens()\n  const airLabelTokens = useAirLabelAllTokens()\n\n  const tokens = useMemo(() => ({ ...allTokens, ...airLabelTokens }), [allTokens, airLabelTokens])\n\n  const address = isAddress(tokenAddress)\n\n  const tokenContract = useTokenContract(address ? address : undefined, false)\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false)\n  const token: Token | undefined = address ? tokens[address] : undefined\n\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD)\n  const tokenNameBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'name',\n    undefined,\n    NEVER_RELOAD\n  )\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD)\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD)\n\n  return useMemo(() => {\n    if (token) return token\n    if (!chainId || !address) return undefined\n    if (decimals.loading || symbol.loading || tokenName.loading) return null\n    if (decimals.result) {\n      return new Token(\n        chainId,\n        address,\n        decimals.result[0],\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token')\n      )\n    }\n    return undefined\n  }, [\n    address,\n    chainId,\n    decimals.loading,\n    decimals.result,\n    symbol.loading,\n    symbol.result,\n    symbolBytes32.result,\n    token,\n    tokenName.loading,\n    tokenName.result,\n    tokenNameBytes32.result\n  ])\n}\n\nexport function useCurrency(currencyId: string | undefined): Currency | null | undefined {\n  // const isETH = currencyId?.toUpperCase() === 'ETH'\n  // const token = useToken(isETH ? undefined : currencyId)\n  // return isETH ? ETHER : token\n  return useToken(currencyId)\n}\n"]},"metadata":{},"sourceType":"module"}