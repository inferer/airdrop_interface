{"ast":null,"code":"import { createReducer } from '@reduxjs/toolkit';\nimport { DEFAULT_LIST_OF_LISTS, DEFAULT_TOKEN_LIST_URL } from '../../constants/lists';\nimport { updateVersion } from '../global/actions';\nimport { acceptListUpdate, addList, fetchTokenList, removeList, selectList } from './actions';\nimport UNISWAP_DEFAULT_LIST from '@uniswap/default-token-list';\nconst NEW_LIST_STATE = {\n  error: null,\n  current: null,\n  loadingRequestId: null,\n  pendingUpdate: null\n};\nconst initialState = {\n  lastInitializedDefaultListOfLists: DEFAULT_LIST_OF_LISTS,\n  byUrl: { ...DEFAULT_LIST_OF_LISTS.reduce((memo, listUrl) => {\n      memo[listUrl] = NEW_LIST_STATE;\n      return memo;\n    }, {}),\n    [DEFAULT_TOKEN_LIST_URL]: {\n      error: null,\n      current: UNISWAP_DEFAULT_LIST,\n      loadingRequestId: null,\n      pendingUpdate: null\n    }\n  },\n  selectedListUrl: DEFAULT_TOKEN_LIST_URL\n};\nexport default createReducer(initialState, builder => builder.addCase(fetchTokenList.pending, (state, {\n  payload: {\n    requestId,\n    url\n  }\n}) => {// state.byUrl[url] = {\n  //   current: null,\n  //   pendingUpdate: null,\n  //   ...state.byUrl[url],\n  //   loadingRequestId: requestId,\n  //   error: null\n  // }\n}).addCase(fetchTokenList.fulfilled, (state, {\n  payload: {\n    requestId,\n    tokenList,\n    url\n  }\n}) => {\n  var _state$byUrl$url, _state$byUrl$url2;\n\n  console.log(url, tokenList);\n  const current = (_state$byUrl$url = state.byUrl[url]) === null || _state$byUrl$url === void 0 ? void 0 : _state$byUrl$url.current;\n  const loadingRequestId = (_state$byUrl$url2 = state.byUrl[url]) === null || _state$byUrl$url2 === void 0 ? void 0 : _state$byUrl$url2.loadingRequestId; // no-op if update does nothing\n  // if (current) {\n  //   const upgradeType = getVersionUpgrade(current.version, tokenList.version)\n  //   if (upgradeType === VersionUpgrade.NONE) return\n  //   if (loadingRequestId === null || loadingRequestId === requestId) {\n  //     state.byUrl[url] = {\n  //       ...state.byUrl[url],\n  //       loadingRequestId: null,\n  //       error: null,\n  //       current: current,\n  //       pendingUpdate: tokenList\n  //     }\n  //   }\n  // } else {\n  //   state.byUrl[url] = {\n  //     ...state.byUrl[url],\n  //     loadingRequestId: null,\n  //     error: null,\n  //     current: tokenList,\n  //     pendingUpdate: null\n  //   }\n  // }\n}).addCase(fetchTokenList.rejected, (state, {\n  payload: {\n    url,\n    requestId,\n    errorMessage\n  }\n}) => {\n  var _state$byUrl$url3;\n\n  if (((_state$byUrl$url3 = state.byUrl[url]) === null || _state$byUrl$url3 === void 0 ? void 0 : _state$byUrl$url3.loadingRequestId) !== requestId) {\n    // no-op since it's not the latest request\n    return;\n  } // state.byUrl[url] = {\n  //   ...state.byUrl[url],\n  //   loadingRequestId: null,\n  //   error: errorMessage,\n  //   current: null,\n  //   pendingUpdate: null\n  // }\n\n}).addCase(selectList, (state, {\n  payload: url\n}) => {// state.selectedListUrl = url\n  // // automatically adds list\n  // if (!state.byUrl[url]) {\n  //   state.byUrl[url] = NEW_LIST_STATE\n  // }\n}).addCase(addList, (state, {\n  payload: url\n}) => {// if (!state.byUrl[url]) {\n  //   state.byUrl[url] = NEW_LIST_STATE\n  // }\n}).addCase(removeList, (state, {\n  payload: url\n}) => {// if (state.byUrl[url]) {\n  //   delete state.byUrl[url]\n  // }\n  // if (state.selectedListUrl === url) {\n  //   state.selectedListUrl = Object.keys(state.byUrl)[0]\n  // }\n}).addCase(acceptListUpdate, (state, {\n  payload: url\n}) => {// if (!state.byUrl[url]?.pendingUpdate) {\n  //   throw new Error('accept list update called without pending update')\n  // }\n  // state.byUrl[url] = {\n  //   ...state.byUrl[url],\n  //   pendingUpdate: null,\n  //   current: state.byUrl[url].pendingUpdate\n  // }\n}).addCase(updateVersion, state => {// state loaded from localStorage, but new lists have never been initialized\n  // if (!state.lastInitializedDefaultListOfLists) {\n  //   state.byUrl = initialState.byUrl\n  //   state.selectedListUrl = undefined\n  // } else if (state.lastInitializedDefaultListOfLists) {\n  //   const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce<Set<string>>(\n  //     (s, l) => s.add(l),\n  //     new Set()\n  //   )\n  //   const newListOfListsSet = DEFAULT_LIST_OF_LISTS.reduce<Set<string>>((s, l) => s.add(l), new Set())\n  //   DEFAULT_LIST_OF_LISTS.forEach(listUrl => {\n  //     if (!lastInitializedSet.has(listUrl)) {\n  //       state.byUrl[listUrl] = NEW_LIST_STATE\n  //     }\n  //   })\n  //   state.lastInitializedDefaultListOfLists.forEach(listUrl => {\n  //     if (!newListOfListsSet.has(listUrl)) {\n  //       delete state.byUrl[listUrl]\n  //     }\n  //   })\n  // }\n  // state.lastInitializedDefaultListOfLists = DEFAULT_LIST_OF_LISTS\n}));","map":{"version":3,"sources":["/Users/xuyanjun/workspace/vision/airdrop_protocol/airdrop_interface/src/state/lists/reducer.ts"],"names":["createReducer","DEFAULT_LIST_OF_LISTS","DEFAULT_TOKEN_LIST_URL","updateVersion","acceptListUpdate","addList","fetchTokenList","removeList","selectList","UNISWAP_DEFAULT_LIST","NEW_LIST_STATE","error","current","loadingRequestId","pendingUpdate","initialState","lastInitializedDefaultListOfLists","byUrl","reduce","memo","listUrl","selectedListUrl","builder","addCase","pending","state","payload","requestId","url","fulfilled","tokenList","console","log","rejected","errorMessage"],"mappings":"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","sourcesContent":["import { createReducer } from '@reduxjs/toolkit'\nimport { getVersionUpgrade, VersionUpgrade } from '@uniswap/token-lists'\nimport { TokenList } from '@uniswap/token-lists/dist/types'\nimport { DEFAULT_LIST_OF_LISTS, DEFAULT_TOKEN_LIST_URL } from '../../constants/lists'\nimport { updateVersion } from '../global/actions'\nimport { acceptListUpdate, addList, fetchTokenList, removeList, selectList } from './actions'\nimport UNISWAP_DEFAULT_LIST from '@uniswap/default-token-list'\n\nexport interface ListsState {\n  readonly byUrl: {\n    readonly [url: string]: {\n      readonly current: TokenList | null\n      readonly pendingUpdate: TokenList | null\n      readonly loadingRequestId: string | null\n      readonly error: string | null\n    }\n  }\n  // this contains the default list of lists from the last time the updateVersion was called, i.e. the app was reloaded\n  readonly lastInitializedDefaultListOfLists?: string[]\n  readonly selectedListUrl: string | undefined\n}\n\nconst NEW_LIST_STATE: ListsState['byUrl'][string] = {\n  error: null,\n  current: null,\n  loadingRequestId: null,\n  pendingUpdate: null\n}\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] extends ReadonlyArray<infer U> ? U[] : T[P] }\n\nconst initialState: ListsState = {\n  lastInitializedDefaultListOfLists: DEFAULT_LIST_OF_LISTS,\n  byUrl: {\n    ...DEFAULT_LIST_OF_LISTS.reduce<Mutable<ListsState['byUrl']>>((memo, listUrl) => {\n      memo[listUrl] = NEW_LIST_STATE\n      return memo\n    }, {}),\n    [DEFAULT_TOKEN_LIST_URL]: {\n      error: null,\n      current: UNISWAP_DEFAULT_LIST,\n      loadingRequestId: null,\n      pendingUpdate: null\n    }\n  },\n  selectedListUrl: DEFAULT_TOKEN_LIST_URL\n}\n\nexport default createReducer(initialState, builder =>\n  builder\n    .addCase(fetchTokenList.pending, (state, { payload: { requestId, url } }) => {\n      // state.byUrl[url] = {\n      //   current: null,\n      //   pendingUpdate: null,\n      //   ...state.byUrl[url],\n      //   loadingRequestId: requestId,\n      //   error: null\n      // }\n    })\n    .addCase(fetchTokenList.fulfilled, (state, { payload: { requestId, tokenList, url } }) => {\n      console.log(url, tokenList)\n      const current = state.byUrl[url]?.current\n      const loadingRequestId = state.byUrl[url]?.loadingRequestId\n      \n      // no-op if update does nothing\n      // if (current) {\n      //   const upgradeType = getVersionUpgrade(current.version, tokenList.version)\n      //   if (upgradeType === VersionUpgrade.NONE) return\n      //   if (loadingRequestId === null || loadingRequestId === requestId) {\n      //     state.byUrl[url] = {\n      //       ...state.byUrl[url],\n      //       loadingRequestId: null,\n      //       error: null,\n      //       current: current,\n      //       pendingUpdate: tokenList\n      //     }\n      //   }\n      // } else {\n      //   state.byUrl[url] = {\n      //     ...state.byUrl[url],\n      //     loadingRequestId: null,\n      //     error: null,\n      //     current: tokenList,\n      //     pendingUpdate: null\n      //   }\n      // }\n    })\n    .addCase(fetchTokenList.rejected, (state, { payload: { url, requestId, errorMessage } }) => {\n      if (state.byUrl[url]?.loadingRequestId !== requestId) {\n        // no-op since it's not the latest request\n        return\n      }\n\n      // state.byUrl[url] = {\n      //   ...state.byUrl[url],\n      //   loadingRequestId: null,\n      //   error: errorMessage,\n      //   current: null,\n      //   pendingUpdate: null\n      // }\n    })\n    .addCase(selectList, (state, { payload: url }) => {\n      // state.selectedListUrl = url\n      // // automatically adds list\n      // if (!state.byUrl[url]) {\n      //   state.byUrl[url] = NEW_LIST_STATE\n      // }\n    })\n    .addCase(addList, (state, { payload: url }) => {\n      // if (!state.byUrl[url]) {\n      //   state.byUrl[url] = NEW_LIST_STATE\n      // }\n    })\n    .addCase(removeList, (state, { payload: url }) => {\n      // if (state.byUrl[url]) {\n      //   delete state.byUrl[url]\n      // }\n      // if (state.selectedListUrl === url) {\n      //   state.selectedListUrl = Object.keys(state.byUrl)[0]\n      // }\n    })\n    .addCase(acceptListUpdate, (state, { payload: url }) => {\n      // if (!state.byUrl[url]?.pendingUpdate) {\n      //   throw new Error('accept list update called without pending update')\n      // }\n      // state.byUrl[url] = {\n      //   ...state.byUrl[url],\n      //   pendingUpdate: null,\n      //   current: state.byUrl[url].pendingUpdate\n      // }\n    })\n    .addCase(updateVersion, state => {\n      // state loaded from localStorage, but new lists have never been initialized\n      // if (!state.lastInitializedDefaultListOfLists) {\n      //   state.byUrl = initialState.byUrl\n      //   state.selectedListUrl = undefined\n      // } else if (state.lastInitializedDefaultListOfLists) {\n      //   const lastInitializedSet = state.lastInitializedDefaultListOfLists.reduce<Set<string>>(\n      //     (s, l) => s.add(l),\n      //     new Set()\n      //   )\n      //   const newListOfListsSet = DEFAULT_LIST_OF_LISTS.reduce<Set<string>>((s, l) => s.add(l), new Set())\n\n      //   DEFAULT_LIST_OF_LISTS.forEach(listUrl => {\n      //     if (!lastInitializedSet.has(listUrl)) {\n      //       state.byUrl[listUrl] = NEW_LIST_STATE\n      //     }\n      //   })\n\n      //   state.lastInitializedDefaultListOfLists.forEach(listUrl => {\n      //     if (!newListOfListsSet.has(listUrl)) {\n      //       delete state.byUrl[listUrl]\n      //     }\n      //   })\n      // }\n\n      // state.lastInitializedDefaultListOfLists = DEFAULT_LIST_OF_LISTS\n    })\n)\n"]},"metadata":{},"sourceType":"module"}