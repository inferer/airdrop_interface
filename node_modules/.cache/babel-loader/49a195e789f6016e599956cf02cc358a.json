{"ast":null,"code":"import _objectSpread from\"/Users/xuyanjun/workspace/vision/airdrop_protocol/airdrop_interface/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import{parseBytes32String}from'@ethersproject/strings';import{ETHER,Token,currencyEquals}from'@uniswap/sdk';import{useMemo}from'react';import{useAirLabelTokenList,useAirTokenList,useSelectedTokenList}from'../state/lists/hooks';import{NEVER_RELOAD,useSingleCallResult}from'../state/multicall/hooks';import{useUserAddedTokens}from'../state/user/hooks';import{isAddress}from'../utils';import{useActiveWeb3React}from'./index';import{useBytes32TokenContract,useTokenContract}from'./useContract';export function useAllTokens(){var _useActiveWeb3React=useActiveWeb3React(),chainId=_useActiveWeb3React.chainId;var userAddedTokens=useUserAddedTokens();var allTokens=useSelectedTokenList();return useMemo(function(){if(!chainId)return{};return allTokens[chainId];// const currentTokens = Object.values(allTokens[chainId])\n// console.log(currentTokens)\n// return (\n//   userAddedTokens\n//     // reduce into all ALL_TOKENS filtered by the current chain\n//     .reduce<{ [address: string]: Token }>(\n//       (tokenMap, token) => {\n//         // console.log(tokenMap, token)\n//         tokenMap[token.address] = token\n//         return tokenMap\n//       },\n//       // must make a copy because reduce modifies the map, and we do not\n//       // want to make a copy in every iteration\n//       { ...allTokens[chainId] }\n//     )\n// )\n},[chainId,userAddedTokens,allTokens]);}export function useAirAllTokens(){var _useActiveWeb3React2=useActiveWeb3React(),chainId=_useActiveWeb3React2.chainId;var userAddedTokens=useUserAddedTokens();var allTokens=useAirTokenList();return useMemo(function(){if(!chainId)return{};return userAddedTokens// reduce into all ALL_TOKENS filtered by the current chain\n.reduce(function(tokenMap,token){tokenMap[token.address]=token;return tokenMap;},// must make a copy because reduce modifies the map, and we do not\n// want to make a copy in every iteration\n_objectSpread({},allTokens[chainId]));},[chainId,userAddedTokens,allTokens]);}export function useAirLabelAllTokens(){var _useActiveWeb3React3=useActiveWeb3React(),chainId=_useActiveWeb3React3.chainId;var userAddedTokens=useUserAddedTokens();var allTokens=useAirLabelTokenList();return useMemo(function(){if(!chainId)return{};return userAddedTokens// reduce into all ALL_TOKENS filtered by the current chain\n.reduce(function(tokenMap,token){tokenMap[token.address]=token;return tokenMap;},// must make a copy because reduce modifies the map, and we do not\n// want to make a copy in every iteration\n_objectSpread({},allTokens[chainId]));},[chainId,userAddedTokens,allTokens]);}// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency){var userAddedTokens=useUserAddedTokens();return!!userAddedTokens.find(function(token){return currencyEquals(currency,token);});}// parse a name or symbol from a token response\nvar BYTES32_REGEX=/^0x[a-fA-F0-9]{64}$/;function parseStringOrBytes32(str,bytes32,defaultValue){return str&&str.length>0?str:bytes32&&BYTES32_REGEX.test(bytes32)?parseBytes32String(bytes32):defaultValue;}// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress){var _useActiveWeb3React4=useActiveWeb3React(),chainId=_useActiveWeb3React4.chainId;var allTokens=useAllTokens();var airLabelTokens=useAirLabelAllTokens();var tokens=useMemo(function(){return _objectSpread(_objectSpread({},allTokens),airLabelTokens);},[allTokens,airLabelTokens]);var address=isAddress(tokenAddress);var tokenContract=useTokenContract(address?address:undefined,false);var tokenContractBytes32=useBytes32TokenContract(address?address:undefined,false);var token=address?tokens[address]:undefined;var tokenName=useSingleCallResult(token?undefined:tokenContract,'name',undefined,NEVER_RELOAD);var tokenNameBytes32=useSingleCallResult(token?undefined:tokenContractBytes32,'name',undefined,NEVER_RELOAD);var symbol=useSingleCallResult(token?undefined:tokenContract,'symbol',undefined,NEVER_RELOAD);var symbolBytes32=useSingleCallResult(token?undefined:tokenContractBytes32,'symbol',undefined,NEVER_RELOAD);var decimals=useSingleCallResult(token?undefined:tokenContract,'decimals',undefined,NEVER_RELOAD);return useMemo(function(){if(token)return token;if(!chainId||!address)return undefined;if(decimals.loading||symbol.loading||tokenName.loading)return null;if(decimals.result){var _symbol$result,_symbolBytes32$result,_tokenName$result,_tokenNameBytes32$res;return new Token(chainId,address,decimals.result[0],parseStringOrBytes32((_symbol$result=symbol.result)===null||_symbol$result===void 0?void 0:_symbol$result[0],(_symbolBytes32$result=symbolBytes32.result)===null||_symbolBytes32$result===void 0?void 0:_symbolBytes32$result[0],'UNKNOWN'),parseStringOrBytes32((_tokenName$result=tokenName.result)===null||_tokenName$result===void 0?void 0:_tokenName$result[0],(_tokenNameBytes32$res=tokenNameBytes32.result)===null||_tokenNameBytes32$res===void 0?void 0:_tokenNameBytes32$res[0],'Unknown Token'));}return undefined;},[address,chainId,decimals.loading,decimals.result,symbol.loading,symbol.result,symbolBytes32.result,token,tokenName.loading,tokenName.result,tokenNameBytes32.result]);}export function useCurrency(currencyId){var isETH=(currencyId===null||currencyId===void 0?void 0:currencyId.toUpperCase())==='ETH';var token=useToken(isETH?undefined:currencyId);return isETH?ETHER:token;// return useToken(currencyId)\n}","map":{"version":3,"sources":["/Users/xuyanjun/workspace/vision/airdrop_protocol/airdrop_interface/src/hooks/Tokens.ts"],"names":["parseBytes32String","ETHER","Token","currencyEquals","useMemo","useAirLabelTokenList","useAirTokenList","useSelectedTokenList","NEVER_RELOAD","useSingleCallResult","useUserAddedTokens","isAddress","useActiveWeb3React","useBytes32TokenContract","useTokenContract","useAllTokens","chainId","userAddedTokens","allTokens","useAirAllTokens","reduce","tokenMap","token","address","useAirLabelAllTokens","useIsUserAddedToken","currency","find","BYTES32_REGEX","parseStringOrBytes32","str","bytes32","defaultValue","length","test","useToken","tokenAddress","airLabelTokens","tokens","tokenContract","undefined","tokenContractBytes32","tokenName","tokenNameBytes32","symbol","symbolBytes32","decimals","loading","result","useCurrency","currencyId","isETH","toUpperCase"],"mappings":"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","sourcesContent":["import { parseBytes32String } from '@ethersproject/strings'\nimport { Currency, ETHER, Token, currencyEquals } from '@uniswap/sdk'\nimport { useMemo } from 'react'\nimport { useAirLabelTokenList, useAirTokenList, useSelectedTokenList } from '../state/lists/hooks'\nimport { NEVER_RELOAD, useSingleCallResult } from '../state/multicall/hooks'\nimport { useAddUserToken, useUserAddedTokens } from '../state/user/hooks'\nimport { isAddress } from '../utils'\n\nimport { useActiveWeb3React } from './index'\nimport { useBytes32TokenContract, useTokenContract } from './useContract'\n\nexport function useAllTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const userAddedTokens = useUserAddedTokens()\n  const allTokens = useSelectedTokenList()\n  return useMemo(() => {\n    if (!chainId) return {}\n    return allTokens[chainId]\n    // const currentTokens = Object.values(allTokens[chainId])\n    // console.log(currentTokens)\n    // return (\n    //   userAddedTokens\n    //     // reduce into all ALL_TOKENS filtered by the current chain\n    //     .reduce<{ [address: string]: Token }>(\n    //       (tokenMap, token) => {\n    //         // console.log(tokenMap, token)\n    //         tokenMap[token.address] = token\n    //         return tokenMap\n    //       },\n    //       // must make a copy because reduce modifies the map, and we do not\n    //       // want to make a copy in every iteration\n    //       { ...allTokens[chainId] }\n    //     )\n    // )\n  }, [chainId, userAddedTokens, allTokens])\n}\n\n\nexport function useAirAllTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const userAddedTokens = useUserAddedTokens()\n  const allTokens = useAirTokenList()\n\n  return useMemo(() => {\n    if (!chainId) return {}\n    return (\n      userAddedTokens\n        // reduce into all ALL_TOKENS filtered by the current chain\n        .reduce<{ [address: string]: Token }>(\n          (tokenMap, token) => {\n            tokenMap[token.address] = token\n            return tokenMap\n          },\n          // must make a copy because reduce modifies the map, and we do not\n          // want to make a copy in every iteration\n          { ...allTokens[chainId] }\n        )\n    )\n  }, [chainId, userAddedTokens, allTokens])\n}\n\nexport function useAirLabelAllTokens(): { [address: string]: Token } {\n  const { chainId } = useActiveWeb3React()\n  const userAddedTokens = useUserAddedTokens()\n  const allTokens = useAirLabelTokenList()\n\n  return useMemo(() => {\n    if (!chainId) return {}\n    return (\n      userAddedTokens\n        // reduce into all ALL_TOKENS filtered by the current chain\n        .reduce<{ [address: string]: Token }>(\n          (tokenMap, token) => {\n            tokenMap[token.address] = token\n            return tokenMap\n          },\n          // must make a copy because reduce modifies the map, and we do not\n          // want to make a copy in every iteration\n          { ...allTokens[chainId] }\n        )\n    )\n  }, [chainId, userAddedTokens, allTokens])\n}\n\n// Check if currency is included in custom list from user storage\nexport function useIsUserAddedToken(currency: Currency): boolean {\n  const userAddedTokens = useUserAddedTokens()\n  return !!userAddedTokens.find(token => currencyEquals(currency, token))\n}\n\n// parse a name or symbol from a token response\nconst BYTES32_REGEX = /^0x[a-fA-F0-9]{64}$/\nfunction parseStringOrBytes32(str: string | undefined, bytes32: string | undefined, defaultValue: string): string {\n  return str && str.length > 0\n    ? str\n    : bytes32 && BYTES32_REGEX.test(bytes32)\n    ? parseBytes32String(bytes32)\n    : defaultValue\n}\n\n// undefined if invalid or does not exist\n// null if loading\n// otherwise returns the token\nexport function useToken(tokenAddress?: string): Token | undefined | null {\n  const { chainId } = useActiveWeb3React()\n  const allTokens = useAllTokens()\n  const airLabelTokens = useAirLabelAllTokens()\n\n  const tokens = useMemo(() => ({ ...allTokens, ...airLabelTokens }), [allTokens, airLabelTokens])\n\n  const address = isAddress(tokenAddress)\n\n  const tokenContract = useTokenContract(address ? address : undefined, false)\n  const tokenContractBytes32 = useBytes32TokenContract(address ? address : undefined, false)\n  const token: Token | undefined = address ? tokens[address] : undefined\n\n  const tokenName = useSingleCallResult(token ? undefined : tokenContract, 'name', undefined, NEVER_RELOAD)\n  const tokenNameBytes32 = useSingleCallResult(\n    token ? undefined : tokenContractBytes32,\n    'name',\n    undefined,\n    NEVER_RELOAD\n  )\n  const symbol = useSingleCallResult(token ? undefined : tokenContract, 'symbol', undefined, NEVER_RELOAD)\n  const symbolBytes32 = useSingleCallResult(token ? undefined : tokenContractBytes32, 'symbol', undefined, NEVER_RELOAD)\n  const decimals = useSingleCallResult(token ? undefined : tokenContract, 'decimals', undefined, NEVER_RELOAD)\n\n  return useMemo(() => {\n    if (token) return token\n    if (!chainId || !address) return undefined\n    if (decimals.loading || symbol.loading || tokenName.loading) return null\n    if (decimals.result) {\n      return new Token(\n        chainId,\n        address,\n        decimals.result[0],\n        parseStringOrBytes32(symbol.result?.[0], symbolBytes32.result?.[0], 'UNKNOWN'),\n        parseStringOrBytes32(tokenName.result?.[0], tokenNameBytes32.result?.[0], 'Unknown Token')\n      )\n    }\n    return undefined\n  }, [\n    address,\n    chainId,\n    decimals.loading,\n    decimals.result,\n    symbol.loading,\n    symbol.result,\n    symbolBytes32.result,\n    token,\n    tokenName.loading,\n    tokenName.result,\n    tokenNameBytes32.result\n  ])\n}\n\nexport function useCurrency(currencyId: string | undefined): Currency | null | undefined {\n  const isETH = currencyId?.toUpperCase() === 'ETH'\n  const token = useToken(isETH ? undefined : currencyId)\n  return isETH ? ETHER : token\n  // return useToken(currencyId)\n}\n"]},"metadata":{},"sourceType":"module"}