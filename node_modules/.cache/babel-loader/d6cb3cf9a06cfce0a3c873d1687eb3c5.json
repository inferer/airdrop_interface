{"ast":null,"code":"import { Pair, Token } from '@uniswap/sdk';\nimport flatMap from 'lodash.flatmap';\nimport { useCallback, useMemo } from 'react';\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux';\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS, UserRoleMode } from '../../constants';\nimport { useActiveWeb3React } from '../../hooks';\nimport { useAllTokens } from '../../hooks/Tokens';\nimport { addSerializedPair, addSerializedToken, removeSerializedToken, updateUserDarkMode, updateUserDeadline, updateUserExpertMode, updateUserSlippageTolerance, updateUserRoleMode } from './actions';\nimport { airdropV2, airdropV2Swap, getUserNonce } from './api';\nimport { useUserModeInputCurrency } from '../swap/hooks';\n\nfunction serializeToken(token) {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name\n  };\n}\n\nfunction deserializeToken(serializedToken) {\n  return new Token(serializedToken.chainId, serializedToken.address, serializedToken.decimals, serializedToken.symbol, serializedToken.name);\n}\n\nexport function useIsDarkMode() {\n  const {\n    userDarkMode,\n    matchesDarkMode\n  } = useSelector(({\n    user: {\n      matchesDarkMode,\n      userDarkMode\n    }\n  }) => ({\n    userDarkMode,\n    matchesDarkMode\n  }), shallowEqual);\n  return userDarkMode === null ? matchesDarkMode : userDarkMode;\n}\nexport function useIsRoleProjectMode() {\n  const roleMode = useSelector(state => state.user.userRoleMode);\n  return useMemo(() => roleMode === UserRoleMode.PROJECT, [roleMode]);\n}\nexport function useUserRoleMode() {\n  const dispatch = useDispatch();\n  const {\n    handleReplaceSwapState\n  } = useUserModeInputCurrency();\n  const isProjectMode = useIsRoleProjectMode();\n  const toggleSetUserRoleMode = useCallback(() => {\n    dispatch(updateUserRoleMode({\n      userRoleMode: isProjectMode ? UserRoleMode.USER : UserRoleMode.PROJECT\n    }));\n    handleReplaceSwapState(!isProjectMode);\n  }, [isProjectMode, dispatch, handleReplaceSwapState]);\n  return [isProjectMode, toggleSetUserRoleMode];\n}\nexport function useDarkModeManager() {\n  const dispatch = useDispatch();\n  const darkMode = useIsDarkMode();\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({\n      userDarkMode: !darkMode\n    }));\n  }, [darkMode, dispatch]);\n  return [darkMode, toggleSetDarkMode];\n}\nexport function useIsExpertMode() {\n  return useSelector(state => state.user.userExpertMode);\n}\nexport function useExpertModeManager() {\n  const dispatch = useDispatch();\n  const expertMode = useIsExpertMode();\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({\n      userExpertMode: !expertMode\n    }));\n  }, [expertMode, dispatch]);\n  return [expertMode, toggleSetExpertMode];\n}\nexport function useUserSlippageTolerance() {\n  const dispatch = useDispatch();\n  const userSlippageTolerance = useSelector(state => {\n    return state.user.userSlippageTolerance;\n  });\n  const setUserSlippageTolerance = useCallback(userSlippageTolerance => {\n    dispatch(updateUserSlippageTolerance({\n      userSlippageTolerance\n    }));\n  }, [dispatch]);\n  return [userSlippageTolerance, setUserSlippageTolerance];\n}\nexport function useUserDeadline() {\n  const dispatch = useDispatch();\n  const userDeadline = useSelector(state => {\n    return state.user.userDeadline;\n  });\n  const setUserDeadline = useCallback(userDeadline => {\n    dispatch(updateUserDeadline({\n      userDeadline\n    }));\n  }, [dispatch]);\n  return [userDeadline, setUserDeadline];\n}\nexport function useAddUserToken() {\n  const dispatch = useDispatch();\n  return useCallback(token => {\n    dispatch(addSerializedToken({\n      serializedToken: serializeToken(token)\n    }));\n  }, [dispatch]);\n}\nexport function useRemoveUserAddedToken() {\n  const dispatch = useDispatch();\n  return useCallback((chainId, address) => {\n    dispatch(removeSerializedToken({\n      chainId,\n      address\n    }));\n  }, [dispatch]);\n}\nexport function useUserAddedTokens() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const serializedTokensMap = useSelector(({\n    user: {\n      tokens\n    }\n  }) => tokens);\n  return useMemo(() => {\n    var _serializedTokensMap;\n\n    if (!chainId) return [];\n    return Object.values((_serializedTokensMap = serializedTokensMap[chainId]) !== null && _serializedTokensMap !== void 0 ? _serializedTokensMap : {}).map(deserializeToken);\n  }, [serializedTokensMap, chainId]);\n}\n\nfunction serializePair(pair) {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1)\n  };\n}\n\nexport function usePairAdder() {\n  const dispatch = useDispatch();\n  return useCallback(pair => {\n    dispatch(addSerializedPair({\n      serializedPair: serializePair(pair)\n    }));\n  }, [dispatch]);\n}\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\n\nexport function toV2LiquidityToken([tokenA, tokenB]) {\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, 'UNI-V2', 'Uniswap V2');\n}\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\n\nexport function useTrackedTokenPairs() {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const tokens = useAllTokens(); // pinned pairs\n\n  const pinnedPairs = useMemo(() => {\n    var _PINNED_PAIRS$chainId;\n\n    return chainId ? (_PINNED_PAIRS$chainId = PINNED_PAIRS[chainId]) !== null && _PINNED_PAIRS$chainId !== void 0 ? _PINNED_PAIRS$chainId : [] : [];\n  }, [chainId]); // pairs for every token against every base\n\n  const generatedPairs = useMemo(() => chainId ? flatMap(Object.keys(tokens), tokenAddress => {\n    var _BASES_TO_TRACK_LIQUI;\n\n    const token = tokens[tokenAddress]; // for each token on the current chain,\n\n    return (// loop though all bases on the current chain\n      ((_BASES_TO_TRACK_LIQUI = BASES_TO_TRACK_LIQUIDITY_FOR[chainId]) !== null && _BASES_TO_TRACK_LIQUI !== void 0 ? _BASES_TO_TRACK_LIQUI : []). // to construct pairs of the given token with each base\n      map(base => {\n        if (base.address === token.address) {\n          return null;\n        } else {\n          return [base, token];\n        }\n      }).filter(p => p !== null)\n    );\n  }) : [], [tokens, chainId]); // pairs saved by users\n\n  const savedSerializedPairs = useSelector(({\n    user: {\n      pairs\n    }\n  }) => pairs);\n  const userPairs = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return [];\n    const forChain = savedSerializedPairs[chainId];\n    if (!forChain) return [];\n    return Object.keys(forChain).map(pairId => {\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)];\n    });\n  }, [savedSerializedPairs, chainId]);\n  const combinedList = useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [generatedPairs, pinnedPairs, userPairs]);\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce((memo, [tokenA, tokenB]) => {\n      const sorted = tokenA.sortsBefore(tokenB);\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`;\n      if (memo[key]) return memo;\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA];\n      return memo;\n    }, {});\n    return Object.keys(keyed).map(key => keyed[key]);\n  }, [combinedList]);\n}\nexport function useAirdrop() {\n  const {\n    account\n  } = useActiveWeb3React();\n  const handleAirdrop = useCallback(async (algToken, totalAmount) => {\n    // return\n    if (account) {\n      const res = await getUserNonce(account);\n\n      if (res.code === 0) {\n        const msg = `0x${Buffer.from(res.data.nonce, 'utf8').toString('hex')}`; // @ts-ignore\n\n        const sign = await window.ethereum.request({\n          method: 'personal_sign',\n          params: [msg, account, 'Inferer']\n        }); // const totalAmount = '1000000000000000000000'\n\n        const airdropRes = await airdropV2(account, sign, totalAmount + '000000000000000000', algToken);\n        console.log(airdropRes);\n      }\n    }\n  }, [account, getUserNonce]);\n  const handleAirdropSwap = useCallback(async (algTokenAddress, airTokenAddress) => {\n    if (account) {\n      const res = await getUserNonce(account);\n\n      if (res.code === 0) {\n        const msg = `0x${Buffer.from(res.data.nonce, 'utf8').toString('hex')}`; // @ts-ignore\n\n        const sign = await window.ethereum.request({\n          method: 'personal_sign',\n          params: [msg, account, 'Inferer']\n        });\n        const amount = '200000000000000000';\n        const swpRes = await airdropV2Swap(account, sign, [account], [amount], algTokenAddress, airTokenAddress);\n        console.log(swpRes);\n      }\n    }\n  }, [account, getUserNonce]);\n  return {\n    handleAirdrop,\n    handleAirdropSwap\n  };\n}","map":{"version":3,"sources":["/Users/xuyanjun/workspace/vision/airdrop_protocol/airdrop_interface/src/state/user/hooks.tsx"],"names":["Pair","Token","flatMap","useCallback","useMemo","shallowEqual","useDispatch","useSelector","BASES_TO_TRACK_LIQUIDITY_FOR","PINNED_PAIRS","UserRoleMode","useActiveWeb3React","useAllTokens","addSerializedPair","addSerializedToken","removeSerializedToken","updateUserDarkMode","updateUserDeadline","updateUserExpertMode","updateUserSlippageTolerance","updateUserRoleMode","airdropV2","airdropV2Swap","getUserNonce","useUserModeInputCurrency","serializeToken","token","chainId","address","decimals","symbol","name","deserializeToken","serializedToken","useIsDarkMode","userDarkMode","matchesDarkMode","user","useIsRoleProjectMode","roleMode","state","userRoleMode","PROJECT","useUserRoleMode","dispatch","handleReplaceSwapState","isProjectMode","toggleSetUserRoleMode","USER","useDarkModeManager","darkMode","toggleSetDarkMode","useIsExpertMode","userExpertMode","useExpertModeManager","expertMode","toggleSetExpertMode","useUserSlippageTolerance","userSlippageTolerance","setUserSlippageTolerance","useUserDeadline","userDeadline","setUserDeadline","useAddUserToken","useRemoveUserAddedToken","useUserAddedTokens","serializedTokensMap","tokens","Object","values","map","serializePair","pair","token0","token1","usePairAdder","serializedPair","toV2LiquidityToken","tokenA","tokenB","getAddress","useTrackedTokenPairs","pinnedPairs","generatedPairs","keys","tokenAddress","base","filter","p","savedSerializedPairs","pairs","userPairs","forChain","pairId","combinedList","concat","keyed","reduce","memo","sorted","sortsBefore","key","useAirdrop","account","handleAirdrop","algToken","totalAmount","res","code","msg","Buffer","from","data","nonce","toString","sign","window","ethereum","request","method","params","airdropRes","console","log","handleAirdropSwap","algTokenAddress","airTokenAddress","amount","swpRes"],"mappings":"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","sourcesContent":["import { ChainId, Pair, Token } from '@uniswap/sdk'\nimport flatMap from 'lodash.flatmap'\nimport { useCallback, useMemo } from 'react'\nimport { shallowEqual, useDispatch, useSelector } from 'react-redux'\nimport { BASES_TO_TRACK_LIQUIDITY_FOR, PINNED_PAIRS, UserRoleMode } from '../../constants'\n\nimport { useActiveWeb3React } from '../../hooks'\nimport { useAllTokens } from '../../hooks/Tokens'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  addSerializedPair,\n  addSerializedToken,\n  removeSerializedToken,\n  SerializedPair,\n  SerializedToken,\n  updateUserDarkMode,\n  updateUserDeadline,\n  updateUserExpertMode,\n  updateUserSlippageTolerance,\n  updateUserRoleMode\n} from './actions'\nimport { airdropV2, airdropV2Swap, getUserNonce } from './api'\nimport { useUserModeInputCurrency } from '../swap/hooks'\n\nfunction serializeToken(token: Token): SerializedToken {\n  return {\n    chainId: token.chainId,\n    address: token.address,\n    decimals: token.decimals,\n    symbol: token.symbol,\n    name: token.name\n  }\n}\n\nfunction deserializeToken(serializedToken: SerializedToken): Token {\n  return new Token(\n    serializedToken.chainId,\n    serializedToken.address,\n    serializedToken.decimals,\n    serializedToken.symbol,\n    serializedToken.name\n  )\n}\n\nexport function useIsDarkMode(): boolean {\n  const { userDarkMode, matchesDarkMode } = useSelector<\n    AppState,\n    { userDarkMode: boolean | null; matchesDarkMode: boolean }\n  >(\n    ({ user: { matchesDarkMode, userDarkMode } }) => ({\n      userDarkMode,\n      matchesDarkMode\n    }),\n    shallowEqual\n  )\n\n  return userDarkMode === null ? matchesDarkMode : userDarkMode\n}\n\nexport function useIsRoleProjectMode(): boolean {\n  const roleMode = useSelector<AppState, AppState['user']['userRoleMode']>(state => state.user.userRoleMode)\n  return useMemo(() => roleMode === UserRoleMode.PROJECT , [roleMode])\n}\n\nexport function useUserRoleMode(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const { handleReplaceSwapState } = useUserModeInputCurrency()\n\n  const isProjectMode = useIsRoleProjectMode()\n\n  const toggleSetUserRoleMode = useCallback(() => {\n    dispatch(updateUserRoleMode({ userRoleMode: isProjectMode ? UserRoleMode.USER : UserRoleMode.PROJECT }))\n    handleReplaceSwapState(!isProjectMode)\n  }, [isProjectMode, dispatch, handleReplaceSwapState])\n\n  return [isProjectMode, toggleSetUserRoleMode]\n}\n\nexport function useDarkModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const darkMode = useIsDarkMode()\n\n  const toggleSetDarkMode = useCallback(() => {\n    dispatch(updateUserDarkMode({ userDarkMode: !darkMode }))\n  }, [darkMode, dispatch])\n\n  return [darkMode, toggleSetDarkMode]\n}\n\nexport function useIsExpertMode(): boolean {\n  return useSelector<AppState, AppState['user']['userExpertMode']>(state => state.user.userExpertMode)\n}\n\nexport function useExpertModeManager(): [boolean, () => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const expertMode = useIsExpertMode()\n\n  const toggleSetExpertMode = useCallback(() => {\n    dispatch(updateUserExpertMode({ userExpertMode: !expertMode }))\n  }, [expertMode, dispatch])\n\n  return [expertMode, toggleSetExpertMode]\n}\n\nexport function useUserSlippageTolerance(): [number, (slippage: number) => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const userSlippageTolerance = useSelector<AppState, AppState['user']['userSlippageTolerance']>(state => {\n    return state.user.userSlippageTolerance\n  })\n\n  const setUserSlippageTolerance = useCallback(\n    (userSlippageTolerance: number) => {\n      dispatch(updateUserSlippageTolerance({ userSlippageTolerance }))\n    },\n    [dispatch]\n  )\n\n  return [userSlippageTolerance, setUserSlippageTolerance]\n}\n\nexport function useUserDeadline(): [number, (slippage: number) => void] {\n  const dispatch = useDispatch<AppDispatch>()\n  const userDeadline = useSelector<AppState, AppState['user']['userDeadline']>(state => {\n    return state.user.userDeadline\n  })\n\n  const setUserDeadline = useCallback(\n    (userDeadline: number) => {\n      dispatch(updateUserDeadline({ userDeadline }))\n    },\n    [dispatch]\n  )\n\n  return [userDeadline, setUserDeadline]\n}\n\nexport function useAddUserToken(): (token: Token) => void {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback(\n    (token: Token) => {\n      dispatch(addSerializedToken({ serializedToken: serializeToken(token) }))\n    },\n    [dispatch]\n  )\n}\n\nexport function useRemoveUserAddedToken(): (chainId: number, address: string) => void {\n  const dispatch = useDispatch<AppDispatch>()\n  return useCallback(\n    (chainId: number, address: string) => {\n      dispatch(removeSerializedToken({ chainId, address }))\n    },\n    [dispatch]\n  )\n}\n\nexport function useUserAddedTokens(): Token[] {\n  const { chainId } = useActiveWeb3React()\n  const serializedTokensMap = useSelector<AppState, AppState['user']['tokens']>(({ user: { tokens } }) => tokens)\n  return useMemo(() => {\n    if (!chainId) return []\n    return Object.values(serializedTokensMap[chainId as ChainId] ?? {}).map(deserializeToken)\n  }, [serializedTokensMap, chainId])\n}\n\nfunction serializePair(pair: Pair): SerializedPair {\n  return {\n    token0: serializeToken(pair.token0),\n    token1: serializeToken(pair.token1)\n  }\n}\n\nexport function usePairAdder(): (pair: Pair) => void {\n  const dispatch = useDispatch<AppDispatch>()\n\n  return useCallback(\n    (pair: Pair) => {\n      dispatch(addSerializedPair({ serializedPair: serializePair(pair) }))\n    },\n    [dispatch]\n  )\n}\n\n/**\n * Given two tokens return the liquidity token that represents its liquidity shares\n * @param tokenA one of the two tokens\n * @param tokenB the other token\n */\nexport function toV2LiquidityToken([tokenA, tokenB]: [Token, Token]): Token {\n  return new Token(tokenA.chainId, Pair.getAddress(tokenA, tokenB), 18, 'UNI-V2', 'Uniswap V2')\n}\n\n/**\n * Returns all the pairs of tokens that are tracked by the user for the current chain ID.\n */\nexport function useTrackedTokenPairs(): [Token, Token][] {\n  const { chainId } = useActiveWeb3React()\n  const tokens = useAllTokens()\n\n  // pinned pairs\n  const pinnedPairs = useMemo(() => (chainId ? PINNED_PAIRS[chainId] ?? [] : []), [chainId])\n\n  // pairs for every token against every base\n  const generatedPairs: [Token, Token][] = useMemo(\n    () =>\n      chainId\n        ? flatMap(Object.keys(tokens), tokenAddress => {\n            const token = tokens[tokenAddress]\n            // for each token on the current chain,\n            return (\n              // loop though all bases on the current chain\n              (BASES_TO_TRACK_LIQUIDITY_FOR[chainId] ?? [])\n                // to construct pairs of the given token with each base\n                .map(base => {\n                  if (base.address === token.address) {\n                    return null\n                  } else {\n                    return [base, token]\n                  }\n                })\n                .filter((p): p is [Token, Token] => p !== null)\n            )\n          })\n        : [],\n    [tokens, chainId]\n  )\n\n  // pairs saved by users\n  const savedSerializedPairs = useSelector<AppState, AppState['user']['pairs']>(({ user: { pairs } }) => pairs)\n\n  const userPairs: [Token, Token][] = useMemo(() => {\n    if (!chainId || !savedSerializedPairs) return []\n    const forChain = savedSerializedPairs[chainId]\n    if (!forChain) return []\n\n    return Object.keys(forChain).map(pairId => {\n      return [deserializeToken(forChain[pairId].token0), deserializeToken(forChain[pairId].token1)]\n    })\n  }, [savedSerializedPairs, chainId])\n\n  const combinedList = useMemo(() => userPairs.concat(generatedPairs).concat(pinnedPairs), [\n    generatedPairs,\n    pinnedPairs,\n    userPairs\n  ])\n\n  return useMemo(() => {\n    // dedupes pairs of tokens in the combined list\n    const keyed = combinedList.reduce<{ [key: string]: [Token, Token] }>((memo, [tokenA, tokenB]) => {\n      const sorted = tokenA.sortsBefore(tokenB)\n      const key = sorted ? `${tokenA.address}:${tokenB.address}` : `${tokenB.address}:${tokenA.address}`\n      if (memo[key]) return memo\n      memo[key] = sorted ? [tokenA, tokenB] : [tokenB, tokenA]\n      return memo\n    }, {})\n\n    return Object.keys(keyed).map(key => keyed[key])\n  }, [combinedList])\n}\n\nexport function useAirdrop() {\n  const { account } = useActiveWeb3React() \n  const handleAirdrop = useCallback(async (algToken, totalAmount) => {\n        // return\n    if (account) {\n      \n      const res = await getUserNonce(account)\n      \n      if (res.code === 0) {\n        const msg = `0x${Buffer.from(res.data.nonce, 'utf8').toString('hex')}`;\n        // @ts-ignore\n        const sign = await window.ethereum.request({\n          method: 'personal_sign',\n          params: [msg, account, 'Inferer'],\n        });\n        // const totalAmount = '1000000000000000000000'\n        \n        const airdropRes = await airdropV2(account, sign, totalAmount + '000000000000000000', algToken);\n        console.log(airdropRes)\n\n      }\n    }\n    \n  }, [\n    account,\n    getUserNonce,\n\n  ])\n  const handleAirdropSwap = useCallback(async (algTokenAddress, airTokenAddress) => {\n    if (account) {\n      const res = await getUserNonce(account)\n      \n      if (res.code === 0) {\n        const msg = `0x${Buffer.from(res.data.nonce, 'utf8').toString('hex')}`;\n        // @ts-ignore\n        const sign = await window.ethereum.request({\n          method: 'personal_sign',\n          params: [msg, account, 'Inferer'],\n        });\n        const amount = '200000000000000000'\n        const swpRes = await airdropV2Swap(account, sign, [account], [amount], algTokenAddress, airTokenAddress);\n        console.log(swpRes)\n\n      }\n    }\n    \n  }, [\n    account,\n    getUserNonce,\n\n  ])\n\n  return {\n    handleAirdrop,\n    handleAirdropSwap\n  }\n  \n}\n"]},"metadata":{},"sourceType":"module"}