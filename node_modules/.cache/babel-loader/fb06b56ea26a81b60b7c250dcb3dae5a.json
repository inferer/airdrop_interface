{"ast":null,"code":"import schema from '@uniswap/token-lists/src/tokenlist.schema.json';\nimport Ajv from 'ajv';\nimport contenthashToUri from './contenthashToUri';\nimport { parseENSAddress } from './parseENSAddress';\nimport uriToHttp from './uriToHttp';\nconst tokenListValidator = new Ajv({\n  allErrors: true\n}).compile(schema);\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */\n\nexport default async function getTokenList(listUrl, resolveENSContentHash) {\n  const res = await fetch('/tokens/tokens.json');\n  const json = await res.json();\n\n  if (!tokenListValidator(json)) {\n    var _tokenListValidator$e, _tokenListValidator$e2;\n\n    const validationErrors = (_tokenListValidator$e = (_tokenListValidator$e2 = tokenListValidator.errors) === null || _tokenListValidator$e2 === void 0 ? void 0 : _tokenListValidator$e2.reduce((memo, error) => {\n      var _error$message;\n\n      const add = `${error.dataPath} ${(_error$message = error.message) !== null && _error$message !== void 0 ? _error$message : ''}`;\n      return memo.length > 0 ? `${memo}; ${add}` : `${add}`;\n    }, '')) !== null && _tokenListValidator$e !== void 0 ? _tokenListValidator$e : 'unknown error';\n    throw new Error(`Token list failed validation: ${validationErrors}`);\n  }\n\n  return json;\n  const parsedENS = parseENSAddress(listUrl);\n  let urls;\n\n  if (parsedENS) {\n    var _parsedENS$ensPath;\n\n    let contentHashUri;\n\n    try {\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName);\n    } catch (error) {\n      console.debug(`Failed to resolve ENS name: ${parsedENS.ensName}`, error);\n      throw new Error(`Failed to resolve ENS name: ${parsedENS.ensName}`);\n    }\n\n    let translatedUri;\n\n    try {\n      translatedUri = contenthashToUri(contentHashUri);\n    } catch (error) {\n      console.debug('Failed to translate contenthash to URI', contentHashUri);\n      throw new Error(`Failed to translate contenthash to URI: ${contentHashUri}`);\n    }\n\n    urls = uriToHttp(`${translatedUri}${(_parsedENS$ensPath = parsedENS.ensPath) !== null && _parsedENS$ensPath !== void 0 ? _parsedENS$ensPath : ''}`);\n  } else {\n    urls = uriToHttp(listUrl);\n  }\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i];\n    const isLast = i === urls.length - 1;\n    let response;\n\n    try {\n      response = await fetch(url);\n    } catch (error) {\n      console.debug('Failed to fetch list', listUrl, error);\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`);\n      continue;\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`);\n      continue;\n    }\n\n    const json = await response.json();\n\n    if (!tokenListValidator(json)) {\n      var _tokenListValidator$e3, _tokenListValidator$e4;\n\n      const validationErrors = (_tokenListValidator$e3 = (_tokenListValidator$e4 = tokenListValidator.errors) === null || _tokenListValidator$e4 === void 0 ? void 0 : _tokenListValidator$e4.reduce((memo, error) => {\n        var _error$message2;\n\n        const add = `${error.dataPath} ${(_error$message2 = error.message) !== null && _error$message2 !== void 0 ? _error$message2 : ''}`;\n        return memo.length > 0 ? `${memo}; ${add}` : `${add}`;\n      }, '')) !== null && _tokenListValidator$e3 !== void 0 ? _tokenListValidator$e3 : 'unknown error';\n      throw new Error(`Token list failed validation: ${validationErrors}`);\n    }\n\n    return json;\n  }\n\n  throw new Error('Unrecognized list URL protocol.');\n}","map":{"version":3,"sources":["/Users/xuyanjun/workspace/vision/airdrop_protocol/airdrop_interface/src/utils/getTokenList.ts"],"names":["schema","Ajv","contenthashToUri","parseENSAddress","uriToHttp","tokenListValidator","allErrors","compile","getTokenList","listUrl","resolveENSContentHash","res","fetch","json","validationErrors","errors","reduce","memo","error","add","dataPath","message","length","Error","parsedENS","urls","contentHashUri","ensName","console","debug","translatedUri","ensPath","i","url","isLast","response","ok"],"mappings":"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","sourcesContent":["import { TokenList } from '@uniswap/token-lists'\nimport schema from '@uniswap/token-lists/src/tokenlist.schema.json'\nimport Ajv from 'ajv'\nimport contenthashToUri from './contenthashToUri'\nimport { parseENSAddress } from './parseENSAddress'\nimport uriToHttp from './uriToHttp'\n\nconst tokenListValidator = new Ajv({ allErrors: true }).compile(schema)\n\n/**\n * Contains the logic for resolving a list URL to a validated token list\n * @param listUrl list url\n * @param resolveENSContentHash resolves an ens name to a contenthash\n */\nexport default async function getTokenList(\n  listUrl: string,\n  resolveENSContentHash: (ensName: string) => Promise<string>\n): Promise<TokenList> {\n  const res = await fetch('/tokens/tokens.json')\n  const json = await res.json()\n    if (!tokenListValidator(json)) {\n      const validationErrors: string =\n        tokenListValidator.errors?.reduce<string>((memo, error) => {\n          const add = `${error.dataPath} ${error.message ?? ''}`\n          return memo.length > 0 ? `${memo}; ${add}` : `${add}`\n        }, '') ?? 'unknown error'\n      throw new Error(`Token list failed validation: ${validationErrors}`)\n    }\n    return json\n  const parsedENS = parseENSAddress(listUrl)\n  let urls: string[]\n  if (parsedENS) {\n    let contentHashUri\n    try {\n      contentHashUri = await resolveENSContentHash(parsedENS.ensName)\n    } catch (error) {\n      console.debug(`Failed to resolve ENS name: ${parsedENS.ensName}`, error)\n      throw new Error(`Failed to resolve ENS name: ${parsedENS.ensName}`)\n    }\n    let translatedUri\n    try {\n      translatedUri = contenthashToUri(contentHashUri)\n    } catch (error) {\n      console.debug('Failed to translate contenthash to URI', contentHashUri)\n      throw new Error(`Failed to translate contenthash to URI: ${contentHashUri}`)\n    }\n    urls = uriToHttp(`${translatedUri}${parsedENS.ensPath ?? ''}`)\n  } else {\n    urls = uriToHttp(listUrl)\n  }\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const isLast = i === urls.length - 1\n    let response\n    try {\n      response = await fetch(url)\n    } catch (error) {\n      console.debug('Failed to fetch list', listUrl, error)\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    if (!response.ok) {\n      if (isLast) throw new Error(`Failed to download list ${listUrl}`)\n      continue\n    }\n\n    const json = await response.json()\n    if (!tokenListValidator(json)) {\n      const validationErrors: string =\n        tokenListValidator.errors?.reduce<string>((memo, error) => {\n          const add = `${error.dataPath} ${error.message ?? ''}`\n          return memo.length > 0 ? `${memo}; ${add}` : `${add}`\n        }, '') ?? 'unknown error'\n      throw new Error(`Token list failed validation: ${validationErrors}`)\n    }\n    return json\n  }\n  throw new Error('Unrecognized list URL protocol.')\n}\n"]},"metadata":{},"sourceType":"module"}